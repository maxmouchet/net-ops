{
  "name": "Net::Ops",
  "tagline": "Ruby framework for automating network operations.",
  "body": "# Net::Ops\r\n\r\n[![Gem version](http://img.shields.io/gem/v/net-ops.svg)](#)\r\n[![Dependencies](http://img.shields.io/gemnasium/maxmouchet/net-ops.svg)](#)\r\n[![License](http://img.shields.io/badge/license-MIT-blue.svg)](#)\r\n\r\n## Automate daily operations on network devices\r\n\r\nComputers are made to simplify our lives, not make them more complicated. They don't mind doing 1000x the same thing, but too often people do repetitive tasks at hand because they don't know how to write scripts.\r\nI developed this little Ruby module to simplify daily operations on network devices like switches, routers, and access-points.\r\n\r\n**Project Status:** Paused. I may work on it later, but I don't have the time for now. \r\n\r\n### Prerequisites\r\n\r\nI made it to be as simple as possible but, if you want to understand how it works or extend it, you will need some Ruby knowledge.\r\n[The Little Book of Ruby](http://www.sapphiresteel.com/The-Little-Book-Of-Ruby) is a good introduction although convention are not always clear.\r\n[Design Patterns](http://www.amazon.fr/Design-Patterns-Elements-Reusable-Object-Oriented/dp/0201633612) and [Design Patterns in Ruby](http://www.pearsonhighered.com/educator/product/Design-Patterns-in-Ruby/9780321490452.page)\r\nare must read.\r\n[Stack Overflow](http://stackoverflow.com/) is a good place in case of problems.\r\n\r\n### Compatibility\r\n\r\nTested with Cisco IOS and IOS XE devices. Should work partially with NX-OS.\r\nNot compatible with IOS XR and non-Cisco devices but it would be possible to add an abstraction layer in ops.rb to support other brands.\r\n\r\nI implemented only two [transports](#transports), Telnet and SSH. If you want to use another protocol (a serial link for example) you will have to implement it.\r\n\r\n\r\n## Installation\r\n\r\nFirst, you need a Ruby interpreter. [MRI](http://en.wikipedia.org/wiki/Ruby_MRI), the reference implementation, is a good choice. You can download it on [ruby-lang.org](http://www.ruby-lang.org/en/downloads/).\r\nNote that MRI is already included in Mac OS X and most of the Linux distributions.\r\nOn Ubuntu, you can install it with `apt-get install ruby1.9.3`.\r\nThere is other Ruby implementation like [JRuby](http://jruby.org/) or [MagLev](http://maglev.github.io/) but I have not tested my code with them.\r\n\r\nThen you should install net-ops. You can get the latest version from RubyGems:\r\n```bash\r\ngem install 'net-ops' --pre\r\n```\r\n\r\nOr build it from the source:\r\n```bash\r\ngem build net-ops.gemspec\r\ngem install ./net-ops-x.y.z.gem\r\n```\r\n\r\n## Getting started\r\n\r\nYou need to require net/ops in all your scripts and [tasks](#tasks) (we will talk about this later):\r\n\r\n```ruby\r\nrequire 'net/ops'\r\n```\r\n\r\nTo run a script you can double-click on it (on Windows) or issue `ruby my_script.rb` in a terminal.\r\n\r\n### Storing credentials\r\n\r\nWriting directly your username and password directly in the script is a bad idea.\r\nIf you want to keep things simple you can store them in a [YAML](http://en.wikipedia.org/wiki/YAML) file with the following structure:\r\n```yml\r\n# credentials.yml\r\nusername: user1\r\npassword: r5Xqx8\r\n```\r\nThen, to use them in your script:\r\n\r\n```ruby\r\ncredentials = YAML.load_file('credentials.yml')\r\n\r\ncredentials.fetch('username') #=> 'user1'\r\ncredentials.fetch('password') #=> 'r5Xqx8'\r\n```\r\n\r\n*Note 1: If you don't need a username to connect to your device you can either let it empty or specify any value. The field will be ignored.*\r\n*Note 2: Currently the login and the enable password used are the same ([issue #4](https://github.com/maxmouchet/net-ops/issues/4))*\r\n\r\n### Connecting to a device\r\n\r\nConnecting to a device is a two-step process: create a session, and open it.\r\nNothing is sent on the transport until you open the session.\r\n\r\n#### Create the session\r\n\r\nTo create a Session you just need to specify the hostname (or the IP address):\r\n\r\n```ruby\r\n@session = Net::Ops::Session.new('router1.local')\r\n```\r\n\r\n##### Options\r\n\r\nYou can also customize the timeout (`Integer`) and the prompt (`Regexp`) if you want:\r\n\r\n```ruby\r\nhost    = 'router1.local'\r\noptions = { timeout: 10, prompt: /.+(#|>)/ }\r\n\r\n@session = Net::Ops::Session.new(host, options)\r\n```\r\n\r\n##### Logging\r\n\r\nBy default `Session` logs everything from `Level::DEBUG` to `STDOUT`. You can specify a custom logger to the constructor.\r\nFor example to log everything from `Level::WARN` to a file:\r\n```ruby\r\nlogger = Logger.new('logfile.log')\r\nlogger.level = Logger::WARN\r\n\r\n@session = Net::Ops::Session.new(host, options, logger)\r\n```\r\n\r\n#### Open the session\r\n\r\nGiven you loaded your credentials from a YAML file you can open the session like this:\r\n\r\n```ruby\r\n@session.open({ username: credentials.fetch('username'),\r\n               password: credentials.fetch('password') })\r\n```\r\n\r\nNote that this doesn't handle `Net::Ops::TransportUnavailable` which is raised when no transport can be used to open the session.\r\nTo show the error and prevent your script from stopping:\r\n\r\n```ruby\r\nbegin @session.open({ username: '', password: '' })\r\nrescue Net::Ops::TransportUnavailable => e\r\n  puts \"There is an error: #{e.message}\"\r\nend\r\n```\r\n\r\n#### Close the session\r\n\r\nIt is generally not needed to close the session since the Ruby garbage collector will do it automatically.\r\nHowever if you need to, you can call `close`:\r\n```ruby\r\n@session.close\r\n```\r\n\r\n### Sending commands\r\n\r\nOnce the session is opened you can send commands to the device. Net::Ops offer three abstraction levels that are described below.\r\n\r\n#### Raw commands\r\n\r\nThe basic way to send a command and get the output is the `run(command)` method.\r\nIt send command (`String`) followed by a carriage return to the device, wait for the prompt, and return what happened between.\r\nFor example, to get `show int status` output:\r\n\r\n```ruby\r\nputs @session.run('show int status')\r\n```\r\n\r\n`run(command)` is pretty low-level but sometimes you will want to play directly with the transport.\r\nFor example when the command ask for confirmation and doesn't return the prompt (like `reload`). In this case you can do something like this:\r\n```ruby\r\ntransport = @session.transport\r\ntransport.cmd('String' => 'reload', 'Match' => /.+confirm.+/)\r\ntransport.cmd('yes')\r\n```\r\n\r\nTo get the output with `transport.cmd` you need to pass a block:\r\n\r\n```ruby\r\ntransport = @session.transport\r\ntransport.cmd('show version') { |c| puts c }\r\n```\r\n\r\n\r\n#### Basic commands\r\n\r\nTo make your script easier to read, Net::Ops provides methods which are basically alias to Cisco commands.\r\nThese are `get(item)`, `set(item, value)`, `enable(item)`, and `disable(item)`:\r\n```ruby\r\n@session.get 'interfaces status'\r\n# send 'show interfaces status'\r\n\r\n@session.set 'terminal length', 0\r\n# send 'terminal length 0'\r\n\r\n@session.enable 'ip http secure-server'\r\n# send 'ip http secure-server'\r\n\r\n@session.disable 'spanning-tree bpduguard'\r\n# send 'no spanning-tree bpduguard'\r\n```\r\n\r\nThese methods allow you to write a script that are easily readable, but you can do much more by combining them with the [DSL](http://en.wikipedia.org/wiki/Domain-specific_language) that Net::Ops provides.\r\n\r\n#### Domain-specific language\r\n\r\nCurrently the DSL is made of five methods:\r\n* `privileged(&block)`\r\n* `configuration(options = nil, &block)`\r\n* `interface(interface, &block)`\r\n* `interfaces(interfaces, &block)`\r\n* `lines(lines, &block)`\r\n\r\nThey allow you to run commands in the specified context. Note that don't have to prefix methods with `@session` since the block is evaluated inside the session.\r\n\r\nHere's an example of how to use it:\r\n```ruby\r\n# Here we pass a block to be executed in the privileged mode.\r\n@session.privileged do\r\n\r\n  # Let's get interfaces status.\r\n  sw_interfaces = get 'interfaces status'\r\n\r\n  # Show disabled interfaces\r\n  nc_interfaces = sw_interfaces.select { |int| int['status'] == 'disabled' }\r\n  puts nc_interfaces\r\n\r\nend\r\n\r\n# Do some stuff in configuration mode.\r\n@session.configuration do\r\n\r\n  # Add description to Gi1/0/2.\r\n  # Note the singular/plural in interface(s).\r\n  # interface accepts only String as an argument.\r\n  # interfaces accept Array, Regexp, and String.\r\n  interface('Gi1/0/2') do\r\n    set 'description', 'I am Gi1/0/2'\r\n  end\r\n\r\n  # Disable bpduguard on all Gig interfaces.\r\n  interfaces(/Gi1\\/0/) do\r\n    disable 'spanning-tree bpduguard'\r\n  end\r\n\r\nend\r\n\r\n# Copy to startup-config\r\n@session.write!\r\n\r\n# Do something else in configuration mode\r\n# but automatically write this time.\r\n@session.configuration(:enforce_save) do\r\n  disable 'ip http secure-server'\r\nend\r\n```\r\n\r\n#### Other commands\r\n\r\n* `write!`\r\n* `zeroize(item)`\r\n* `generate(item, options)`\r\n\r\nExample :\r\n\r\n```ruby\r\n# Delete the crypto key\r\n@session.zeroize 'crypto key'\r\n\r\n# Regenerate it\r\n@session.generate 'crypto key', 'rsa general-keys modulus 2048'\r\n\r\n# Save running-config\r\n@session.write!\r\n```\r\n\r\n## Tasks\r\nNet::Ops allow to define tasks that perform a specific action and run it on several devices in parallel while handling errors and providing easy logging.\r\n\r\n### Definition\r\nTo define a task you should create a new class that inherit from `Task` and define `initialize` and `work` methods:\r\n\r\n```ruby\r\n# my_task.rb\r\nclass MyTask < Net::Ops::Task\r\n\r\n  def initialize(id)\r\n    # Setup your stuff.\r\n    super(id)\r\n  end\r\n\r\n  def work\r\n    # Place your logic here.\r\n  end\r\n\r\nend\r\n```\r\n\r\n`id` is an identifier that should be unique for each instance of your task. You can use whatever you want, for example, the hostname of the device you are currently working on.\r\n\r\n### Execution\r\nTo run a task you can basically instance it and call work:\r\n\r\n```ruby\r\nt = MyTask.new('task1')\r\nt.work\r\n```\r\n\r\nHowever, you may want to run several tasks in parallel to speed up things. You can do that thanks to [thread/pool](https://github.com/meh/ruby-thread):\r\n\r\n```ruby\r\nhosts = %w( host1 host2 host3 )\r\nmax_conn = 2\r\n\r\npool = Thread.pool(max_conn)\r\n\r\nhosts.each do |hosts|\r\n  pool.process { MyTask.new(host).work }\r\nend\r\n\r\npool.shutdown\r\n```\r\n\r\n## Transports\r\n\r\n### Built-in\r\n\r\n### Custom\r\n```ruby\r\nclass MyCustomTransport\r\n\r\n  def self.open(host, options, credentials)\r\n    session = # Do what you need to get a session to the host.\r\n    return session\r\n  end\r\n\r\nend\r\n```\r\n\r\n## Documentation\r\nYou can get the documentation via gem with `gem server`.\r\nOr generate it manually with `rake doc`.\r\n\r\n## Todo - Ideas\r\n\r\nSee [issues](https://github.com/maxmouchet/net-ops/issues?state=open).\r\n\r\n## Contributing\r\n\r\n1. Fork it\r\n2. Create your feature branch (`git checkout -b my-new-feature`)\r\n3. Commit your changes (`git commit -am 'Add some feature'`)\r\n4. Push to the branch (`git push origin my-new-feature`)\r\n5. Create new Pull Request\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}